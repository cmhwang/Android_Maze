Index: app/src/main/java/edu/wm/cs/cs301/cheyennehwang/gui/FirstPersonView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/**\n * \n */\npackage edu.wm.cs.cs301.cheyennehwang.gui;\n\nimport android.graphics.Color;\nimport android.util.Log;\n\nimport java.util.List;\nimport java.util.logging.Logger;\n\nimport edu.wm.cs.cs301.cheyennehwang.generation.BSPBranch;\nimport edu.wm.cs.cs301.cheyennehwang.generation.BSPLeaf;\nimport edu.wm.cs.cs301.cheyennehwang.generation.BSPNode;\nimport edu.wm.cs.cs301.cheyennehwang.generation.Floorplan;\nimport edu.wm.cs.cs301.cheyennehwang.generation.Wall;\nimport edu.wm.cs.cs301.cheyennehwang.gui.ColorTheme.MazeColors;\n\n/**\n * This class encapsulates all functionality for drawing the current view \n * at the maze from a first person perspective.\n * It is an drawing agent with redraw as its public method to redraw \n * the maze while the user plays, i.e. navigates through the maze.\n *\n * This code is refactored code from Maze.java by Paul Falstad, \n * www.falstad.com, Copyright (C) 1998, all rights reserved\n * Paul Falstad granted permission to modify and use code for teaching purposes.\n * Refactored by Peter Kemper\n */\npublic class FirstPersonView {\n\t/**\n\t * The logger is used to track execution and report issues.\n\t */\n\tprivate static final Logger LOGGER = Logger.getLogger(FirstPersonView.class.getName());\n\n\t// Constants\n\tfinal int viewZ = 50;  // constant from StatePlaying.java\n\t// Instance variables set once and for all in constructor call\n\t// keeps local copies of values determined in StatePlaying.java, \n\t// values are basically constants or shared data structures across \n\t// StatePlaying, MapDrawer and FirstPersonDrawer\n\t// constants, i.e. set in constructor call with values \n\t// that are not subject to change in maze\n\tprivate final int viewWidth;  // = 400;\n\tprivate final int viewHeight; // = 400;\n\tprivate final int mapUnit;    // = 128;\n\tprivate final int stepSize;   // = map_unit/4;\n\t// map scale may be adjusted by user input, controlled in StatePlaying\n\t\n\t/**\n\t * A data structure to store which wallboards have been visible during\n\t * the game. The Map can color highlight such wallboards and the \n\t * FirstPersonDrawer supports this by storing this information.\n\t */\n\tprivate final Floorplan seenWalls;\n\t\n\t/** \n\t * The root node to a tree with walls (Wall objects) in its leaves.\n\t * This data structure carries the information about walls\n\t * to draw. Walls are drawn as filled polygons. \n\t * The content for this tree is determined in MazeBuilder\n\t * when the maze is created. \n\t * It also used to decide visibility of walls.\n\t */\n\tprivate final BSPNode bspRoot;\n\t\n\t/** \n\t * The current viewing angle. This information is used in rotations\n\t * and checking if the bounding box is visible to recognize special cases.\n\t * It is only set in the draw method before the first person\n\t * drawer starts drawing the new first person scene.\n\t * An initial value of 0 matches East.\n\t */\n\tprivate int angle;\n\t\n\t/**\n\t * The current position (x,y) scaled by map_unit and \n\t * modified by the view direction is stored in fields (viewX, viewY).\n\t * Values are set in the draw method. viewX gives the x coordinate,\n\t * viewY the y coordinate.\n\t */\n\tprivate int viewX; \n\tprivate int viewY; \n\t\n\t// set in constructor to then given view_height/2, used in bounding box\n\tprivate final int scaleZ;      // = view_height/2; which is the horizon\n\t\n\t/**\n\t * If one focuses on the x-axis for the first person view \n\t * and looks at the center line (the horizon), one recognizes\n\t * that for any [x,x+1] interval, there is either  \n\t * an opening for the special case of the exit or \n\t * exactly 1 wall shown. So we can keep track of the intervals\n\t * [x,x+delta_x] that we have already drawn a wall for and\n\t * the intervals that still may need to be covered.\n\t * The rset keeps track of candidate intervals that may still\n\t * need to be covered. \n\t * It is initialized in the draw method to cover the whole width\n\t * of the view. \n\t * Whenever polygons for walls are drawn, the covered interval\n\t * is removed from the range set. Which can imply that we either\n\t * shorten overlapping intervals in rset or split an existing \n\t * interval.\n\t * The rset allows us to omit walls that are not needed.\n\t */\n\tprivate RangeSet rSet; \n\t\n\t// debug stuff\n\tprivate boolean deepDebug = false;\n\tprivate boolean allVisible = false;\n\tprivate int traverseNodeCounter;\n\tprivate int traverseWallSectorCounter;\n\tprivate int drawRectCounter;\n\tprivate int drawRectLateCounter;\n\tprivate int drawRectWallCounter;\n\tprivate int nesting = 0;\n\t\n\t/**\n\t * Constructor\n\t * @param width of display\n\t * @param height of display\n\t * @param mapUnit current scaling factor\n\t * @param stepSize size of steps\n\t * @param seenWalls to store which walls were put on display\n\t * @param bspRoot the root node of the bsp tree\n\t */\n\tpublic FirstPersonView(int width, int height, int mapUnit, int stepSize, Floorplan seenWalls, BSPNode bspRoot, MazePanel panel) {\n\t\t// store given parameter values\n\t\tviewWidth = width;\n\t\tviewHeight = height;\n\t\tpanel.setFlexibleDimensions(viewWidth, viewHeight);\n\t\tthis.mapUnit = mapUnit;\n\t\tthis.stepSize = stepSize;\n\t\tthis.seenWalls = seenWalls;\n\t\tthis.bspRoot = bspRoot; \n\t\t// constants and derived values\n\t\tangle = 0; // angle for initial setting of direction is 0 == East, hidden constraint across classes\n\t\tscaleZ = viewHeight/2;\n\t\t// initialize fields\n\t\trSet = new RangeSet();\n\t}\n\t/**\n\t * Draws the first person view on the screen during the game\n\t * @param panel for drawing on the buffer image\n\t * @param x coordinate of current position, only used to set viewX\n\t * @param y coordinate of current position, only used to set viewY\n\t * @param ang gives the current viewing angle\n\t * @param percentToExit gives the distance to exit as a percentage\n\t * @param walkStep, only used to set viewX and viewY\n\t * \n\t */\n\tpublic void draw(MazePanel panel, int x, int y, int walkStep, int ang, float percentToExit) {\n        \n        // update fields angle, viewx, viewy for current position and viewing angle\n        angle = ang ;\n        setView(x, y, walkStep);\n        \n        // update graphics\n        // draw background figure: lightGrey to green on bottom half, yellow to gold on top half\n        drawBackground(panel, percentToExit);\n\n        // reset the set of ranges to a single new element (0,width-1)\n        // to cover the full width of the view \n        // as we have not drawn any polygons (walls) yet.\n        rSet.set(0, viewWidth-1); \n        \n        // debug: reset counters\n        traverseNodeCounter = traverseWallSectorCounter =\n        \t\tdrawRectCounter = drawRectLateCounter = drawRectWallCounter = 0;\n        //\n        drawAllVisibleSectors(bspRoot, panel);\n\t}\n\n\n\t////////////////////////////// internal, private methods ///////////////////////////////\n\tprivate int getViewDX(int angle) {\n\t\treturn (int) (Math.cos(radify(angle))*(1<<16));\n\t}\n\tprivate int getViewDY(int angle) {\n\t\treturn (int) (Math.sin(radify(angle))*(1<<16));\n\t}\n\tfinal double radify(int x) {\n        return x*Math.PI/180;\n    }\n\t/**\n\t * Updates viewX and viewY based on current angle and for current position.\n\t * @param x coordinate of current position\n\t * @param y coordinate of current position\n\t * @param walkStep goes into a scaling factor\n\t */\n\tprivate void setView(int x, int y, int walkStep) {\n\t\t// Notes: only used in draw method\n\t\tfinal int factor = stepSize*walkStep-Constants.VIEW_OFFSET;\n\t\tviewX = (x*mapUnit+mapUnit/2) + unscaleViewD(getViewDX(angle)*factor);\n        viewY = (y*mapUnit+mapUnit/2) + unscaleViewD(getViewDY(angle)*factor);\n\t}\n\t/**\n\t * Draws two solid rectangles to provide a background.\n\t * Note that this also erases previous drawings of maze or map.\n\t * The color setting adjusts to the distance to the exit to \n\t * provide an additional clue for the user.\n\t * Colors transition from yellow to gold and from light grey to green.\n\t * @param panel to draw on, must be not null\n\t * @param percentToExit gives the distance to exit\n\t */\n\tprivate void drawBackground(MazePanel panel, float percentToExit) {\n\t\tpanel.addBackground(percentToExit);\n\n\t}\n\n\t/**\n\t * Recursive method to explore tree of BSP nodes and draw all walls in leaf nodes \n\t * where the bounding box is visible\n\t * @param node is the current node of interest\n\t */\n\tprivate void drawAllVisibleSectors(BSPNode node, MazePanel panel) {\n\t\ttraverseNodeCounter++; // debug\n\t\t\n\t\t// Anchor, stop recursion at leaf nodes\n\t\tif (node.isIsleaf()) {\n\t\t\tdrawAllWallsOfASector((BSPLeaf) node, panel);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// for intermediate nodes proceed recursively through all visible branches\n\t\tBSPBranch n = (BSPBranch) node;\n\t\t\n\t\t// debug code\n\t\tif (deepDebug) {\n\t\t\tdbg(\"                               \".substring(0, nesting) +\n\t\t\t\t\t\"traverse_node \"+n.getX()+\" \"+n.getY()+\" \"+n.getDx()+\" \"+n.getDy()+\" \"+\n\t\t\t\t\tn.getLowerBoundX()+\" \"+n.getLowerBoundY()+\" \"+n.getUpperBoundX()+\" \"+n.getUpperBoundY());\n\t\t}\n\t\tnesting++; // debug\n\t\t\n\t\tfinal int dot = (viewX-n.getX())*n.getDy() - (viewY-n.getY())*n.getDx();\n\t\t// The type of tree traversal depends on the value of dot\n\t\t// either do right before left or vice versa\n\t\t// but only if node is visible at all\n\t\t\n\t\t// if dot >= 0 consider right node before left node\n\t\tBSPNode right = n.getRightBranch();\n\t\tif ((dot >= 0) && (boundingBoxIsVisible(right))) {\n\t\t\tint treeColor = Color.argb(255, 180, 149, 106);\n\t\t\tpanel.setColor(treeColor);\n\t\t\tdrawAllVisibleSectors(right, panel);\n\t\t}\n\t\t// consider left node\n\t\tBSPNode left = n.getLeftBranch();\n\t\tif (boundingBoxIsVisible(left))\n\t\t\tdrawAllVisibleSectors(left, panel);\n\t\t// if dot < 0 consider right node now (after left node)\n\t\tif ((dot < 0) && (boundingBoxIsVisible(right))) {\n\t\t\tint treeColor = Color.argb(255, 180, 149, 106);\n\t\t\tpanel.setColor(treeColor);\n\t\t\tdrawAllVisibleSectors(right, panel);\n\t\t}\n\t\tnesting--; // debug\n\t}\n\t/**\n\t * Decide if the bounding box is visible\n\t * @param node the current node\n\t * @return true if node should be drawn, false otherwise\n\t */\n\tprivate boolean boundingBoxIsVisible(BSPNode node) {\n\t\t\n\t\tif (allVisible) // unused feature, presumably for debugging\n\t\t\treturn true;\n\t\t// check a few simple cases up front\n\t\t// if all x-coordinates are covered with walls,\n\t\t// there nothing left to draw or if the node is outside of viewing angle\n\t\tif (rSet.isEmpty() || isOutOfView(node)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t// calculate x coordinates for two points (x1,y1) and (x2,y2)\n\t\t// to check for an intersection with the range set\n\t\t// calculate 2 intermediate points (p1x,p1y) and (p2x,p2y) first\n\t\t// then derive x1 and x2\n\t\tfinal int xmin = node.getLowerBoundX() - viewX;\n\t\tfinal int ymin = node.getLowerBoundY() - viewY;\n\t\tfinal int xmax = node.getUpperBoundX() - viewX;\n\t\tfinal int ymax = node.getUpperBoundY() - viewY;\n\t\t// initialize (p1x,p1y) and (p2x,p2y) with bounds\n\t\tint p1x = xmin; \n\t\tint p2x = xmax;\n\t\tint p1y = ymin; \n\t\tint p2y = ymax;\n\t\t// adjust (p1x,p1y) and (p2x,p2y) for special cases\n\t\tif (ymin < 0 && ymax > 0) {\n\t\t\tp1y = ymin; \n\t\t\tp2y = ymax;\n\t\t\tif (xmin < 0) {\n\t\t\t\tif (xmax > 0)\n\t\t\t\t\treturn true;\n\t\t\t\tp1x = p2x = xmax;\n\t\t\t} else\n\t\t\t\tp1x = p2x = xmin;\n\t\t} else if (xmin < 0 && xmax > 0) {\n\t\t\tif (ymin < 0)\n\t\t\t\tp1y = p2y = ymax;\n\t\t\telse\n\t\t\t\tp1y = p2y = ymin;\n\t\t} else if ((xmin > 0 && ymin > 0) || (xmin < 0 && ymin < 0)) {\n\t\t\tp1x = xmax; \n\t\t\tp2x = xmin;\n\t\t}\n\t\tRangePair rp = getNewRangePair(p1x, p2x, p1y, p2y);\n\t\tif (!rp.clip3d())\n\t\t\treturn false;\n\t\t// note: zscale == view_height/2 is constant\n\t\tint x1 = rp.x1*scaleZ/rp.z1+(viewWidth/2);\n\t\tint x2 = rp.x2*scaleZ/rp.z2+(viewWidth/2);\n\t\tif (x1 > x2) { //switch if necessary\n\t\t\tint xj = x1;\n\t\t\tx1 = x2;\n\t\t\tx2 = xj;\n\t\t}\n\t\t// constraint: x1 <= x2\n\t\t// if interval [x1,x2] intersects with any of the intervals on \n\t\t// the x-axis that have not been covered with a wall (a polygon)\n\t\t// yet, then this node might be needed.\n\t\treturn (null != rSet.getIntersection(x1, x2));\n\t}\n\t/**\n\t * Instantiates a new RangePair for the given parameters.\n\t * Parameter values are adjusted for the viewing direction.\n\t * @param p1x x coordinate of first point\n\t * @param p2x x coordinate of 2nd point\n\t * @param p1y y coordinate of first point\n\t * @param p2y y coordinate of 2nd point\n\t * @return new RangePair for adjusted parameters\n\t */\n\tprivate RangePair getNewRangePair(int p1x, int p2x, int p1y, int p2y) {\n\t\tint viewDX = getViewDX(angle) ;\n        int viewDY = getViewDY(angle) ;\n\t\t\n        int x1 = -unscaleViewD(viewDY*p1x - viewDX*p1y);\n\t\tint z1 = -unscaleViewD(viewDX*p1x + viewDY*p1y);\n\t\tint x2 = -unscaleViewD(viewDY*p2x - viewDX*p2y);\n\t\tint z2 = -unscaleViewD(viewDX*p2x + viewDY*p2y);\n\t\t\n\t\treturn new RangePair(x1, z1, x2, z2);\n\t}\n\t/**\n\t * Checks if bounding box for current node is out of view.\n\t * @param node the current node\n\t * @return true if any of the special cases match, false otherwise\n\t */\n\tprivate boolean isOutOfView(BSPNode node) {\n\t\tif (angle >= 45 && angle <= 135 && viewY > node.getUpperBoundY())\n\t\t\treturn true;\n\t\tif (angle >= 225 && angle <= 315 && viewY < node.getLowerBoundY())\n\t\t\treturn true;\n\t\tif (angle >= 135 && angle <= 225 && viewX < node.getLowerBoundX())\n\t\t\treturn true;\n\t\tif ((angle >= 315 || angle <= 45) && viewX > node.getUpperBoundX())\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/**\n\t * Traverses all walls of this leaf and draws corresponding rectangles on screen\n\t * @param node is the leaf node\n\t */\n\tprivate void drawAllWallsOfASector(BSPLeaf node, MazePanel panel) {\n\t\tList<Wall> allWalls = node.getAllWalls();\n\t\t// debug\n\t\ttraverseWallSectorCounter++;\n\t\tif (deepDebug) {\n\t\t\tdbg(\"                               \".substring(0, nesting) +\n\t\t\t\t\t\"traverseWallSector \"+node.getLowerBoundX()+\" \"+node.getLowerBoundY()+\n\t\t\t\t\t\" \"+node.getUpperBoundX()+\" \"+node.getUpperBoundY());\n\t\t}\n\t\t// for all walls of this node\n\t\tint i = 0;\n\t\tfor (Wall wall: allWalls) {\n\t\t\t// draw rectangle\n\t\t\tWall thisWall = allWalls.get(i);\n\t\t\tint treeColor = Color.argb(255, 180, 149, 106);\n\t\t\tpanel.setColor(treeColor);\n\t\t\tdrawWall(panel, thisWall);\n\t\t\t// debug\n\t\t\tif (deepDebug) {\n\t\t\t\tdbg(\"                               \".substring(0, nesting) +\n\t\t\t\t\t\t\" traverseWallSector(\" + i +\") \"+\n\t\t\t\t\t\twall.getStartPositionX()+\" \"+wall.getStartPositionY()+\" \"+\n\t\t\t\t\t\twall.getExtensionX()+\" \"+wall.getExtensionY());\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t}\n\t}\n\n\t/**\n\t * Draws wall on screen via graphics attribute gc.\n\t * Helper method for drawAllWallsOfASector.\n\t * @param wall whose seen attribute may be set to true\n\t */\n\tprivate void drawWall(MazePanel panel, Wall wall) {\n\t\tdrawRectCounter++; // debug, counter\n\t\t\n\t\t// some notes: \n\t\t// perspective centers on (centerX,centerY) = (view_width/2,view_height/2)\n\t\t// initialization part for x1, x2, y11, y12, y21, y22\n\t\tfinal int ox1 = wall.getStartPositionX() - viewX;\n\t\tfinal int ox2 = wall.getEndPositionX()   - viewX;\n\t\tfinal int y1  = wall.getStartPositionY() - viewY;\n\t\tfinal int y2  = wall.getEndPositionY()   - viewY;\n\t\t\n\t\tRangePair rp = getNewRangePair(ox1, ox2, y1, y2);\n\t\tif (!rp.clip3d())\n\t\t\treturn;\n\t\t// note: viewZ == 50 is a constant\n\t\t// note: scaleZ == view_height/2 is constant\n\t\tfinal int y11 = viewZ *scaleZ/rp.z1        +(viewHeight/2); \n\t\tfinal int y12 = (viewZ-100) *scaleZ/rp.z1  +(viewHeight/2); \n\t\tfinal int y21 = viewZ *scaleZ/rp.z2        +(viewHeight/2); \n\t\tfinal int y22 = (viewZ-100) *scaleZ/rp.z2  +(viewHeight/2); \n\t\tfinal int x1  = rp.x1 *scaleZ/rp.z1        +(viewWidth/2); \n\t\tfinal int x2  = rp.x2 *scaleZ/rp.z2        +(viewWidth/2); \n\t\t\n\t\trp = null; // added just for clarity, rp not used anymore \n\t\t\n\t\tif (x1 >= x2) /* reject backfaces */\n\t\t\treturn;\n\t\t\n\t\t// moved code for drawing bits and pieces into yet another method to \n\t\t// gain more clarity on what information is actually needed\n\t\tint treeColor = Color.argb(255, 180, 149, 106);\n\t\tpanel.setColor(treeColor);\n\t\tboolean drawn = drawPolygons(x1, x2, y11, y12, y21, y22, panel);\n\t\t\n\t\tif (drawn && !wall.isSeen()) {\n\t\t\twall.setSeen(true); // updates the wall\n\t\t\t// set the seenWalls bit for all wallboards of a wall\n\t\t\t// the wall parameter given is not modified\n\t\t\tseenWalls.addWall(wall, mapUnit); // updates seenWalls\n\t\t}\n\t}\n\t\n\t/**\n\t * Draws all polygons for the parts of a wall that are visible.\n\t * A single wall can contribute more than one polygon on the\n\t * x-axis, e.g. if there is a room with 2 doors on one side\n\t * and the same single long wall may be seen through both\n\t * doors.\n\t * @param x1 is the low end of the interval {@code x1 < x2}\n\t * @param x2 is the high end of the interval\n\t * @param y11\n\t * @param y12\n\t * @param y21\n\t * @param y22\n\t * @return true if at least one polygon has been drawn, false otherwise\n\t */\n\tprivate boolean drawPolygons(int x1, int x2, int y11, int y12, int y21, int y22, MazePanel panel) {\n\t\t// debugging\n\t\t//dbg(drawrect_late_ct + \" drawPieces: \" + x1 + \", \" + x2 \n\t\t//\t\t+ \", \" + y11 + \", \" + y12 + \", \" + y21 + \", \" + y22 );\n\t\tdrawRectLateCounter++; // debug, counter\n\t\t\n\t\t// some constants to improve readability in formulas for yps below\n\t\tfinal int xd = x2 - x1; // length of interval on x-axis\n\t\tfinal int yd1 = y21 - y11;\n\t\tfinal int yd2 = y22 - y12;\n\t\tboolean drawn = false;\n\t\t\n\t\t// go through the interval [x1,x2] and check for possible\n\t\t// intervals on the x-axis that are not covered yet.\n\t\t// Draw a polygon for each subinterval that can be covered.\n\t\t// Loop variable is x1i, starts at x1, upper limit x2 is fixed\n\t\tint x1i = x1; // init loop variable\n\t\tint x2i;      // initialized inside loop\n\t\tint[] intersect;\n\t\twhile (x1i <= x2) {\n\t\t\t// check if there is an intersection, \n\t\t\t// if there is none, done, exit the loop, \n\t\t\t// if there is one, get it as (x1i,x2i)\n\t\t\t// rset represents the to-do list of intervals on the x-axis\n\t\t\t// that are not covered by a polygon yet\n\t\t\t// get one intersection for our interval[x1i,x2] with rset\n\t\t\tintersect = rSet.getIntersection(x1i, x2);\n\t\t\tif (null == intersect){\n//\t\t\t\tLog.v(\"testing\", \"test message\");\n\t\t\t\tbreak; // exit point for loop\n\t\t\t}\n\n\t\t\tx1i = intersect[0]; // progress: can not be less than previous x1i\n\t\t\tx2i = intersect[1]; // x1i <= x2i \n\t\t\t// draw polygon for intersection (x1i,x2i) on x-axis\n\t\t\t// 4 points needed for polygon, \n\t\t\t// case 1: blocking wallboard: \n\t\t\t// => rectangle, 2 vertical lines, 2 horizontal lines\n\t\t\t// case 2: wallboard with perspective: \n\t\t\t// => trapezoid, 2 vertical lines (parallel), \n\t\t\t// 2 lines directed towards center for correct drawing\n\t\t\t// for code below, in both cases\n\t\t\t// 1st line is vertical because 1st & 2nd point have same x coordinate \n\t\t\t// 3rd line is vertical because 3rd & 4th point have same x coordinate\n\t\t\t// constant xd == x2-x1, yd1 = y21-y11, and yd2 = y22-y12\n\t\t\t// the additive term for the y coordinate depends on the point's x coordinate\n\t\t\t// polygon covers interval [x1i, x2i] on the x-axis\n\t\t\tint[] xps = { x1i, x1i, x2i+1, x2i+1 };\n\t\t\t// (x1i-x1)/xd is the percentage of what's left of [x1i,x2i] in [x1,x2]\n\t\t\t// (x2i-x2)/xd is the percentage of what's right of [x1i,x2i] in [x1,x2]\n\t\t\t// memo: warning for refactoring: this is integer division\n\t\t\tint[] yps = { y11+(x1i-x1)*yd1/xd,\n\t\t\t\t\ty12+(x1i-x1)*yd2/xd+1,\n\t\t\t\t\ty22+(x2i-x2)*yd2/xd+1,\n\t\t\t\t\ty21+(x2i-x2)*yd1/xd };\n\t\t\t// debug\n\t\t\t//dbg(\"polygon-x: \" + xps[0] + \", \" + xps[1] + \", \" + xps[2] + \", \" + xps[3]) ;\n\t\t\t//dbg(\"polygon-y: \" + yps[0] + \", \" + yps[1] + \", \" + yps[2] + \", \" + yps[3]) ;\n\t\t\tint treeColor = Color.argb(255, 180, 149, 106);\n\t\t\tpanel.setColor(treeColor);\n\t\t\tpanel.addWall(xps, yps, 4);\n\t\t\t// for debugging purposes, code will draw a red line around polygon\n\t\t\t// this makes individual walls visible\n\t\t\t/*\n\t\t\tgc.setColor(new Color(240,20,20));\n\t\t\tgc.drawPolygon(xps, yps, 4);\n\t\t\tgc.setColor(seg.getColor());\n\t\t\t*/\n\t\t\t// end debugging\n\t\t\tdrawn = true;           // at least one polygon was drawn, memorize for return value\n\t\t\trSet.remove(x1i, x2i);  // update rset, remove interval [x1i,x2i] from to-do list \n\t\t\tx1i = x2i+1;            // progress for while loop, value must increase\n\t\t\t\n\t\t\tdrawRectWallCounter++; // debug, counter\n\t\t}\n\t\treturn drawn;\n\t}\n\t\n\t////////////////////////////// static methods that do not rely on instance fields //////\n\t/**\n\t * Unscale given value\n\t * @param x input value\n\t * @return unscaled input\n\t */\n\tfinal int unscaleViewD(int x) {\n\t\t// >> is the signed right shift operator\n\t\t// shifts input x in its binary representation\n\t\t// 16 times to the right\n\t\t// same as divide by 2^16 and discard remainder\n\t\t// preserves sign\n\t\treturn x >> 16;\n\t}\n\t/**\n\t * Helper method for debugging \n\t * @param str is the message\n\t */\n\tprivate void dbg(String str) {\n\t\tLOGGER.fine(str);\n\t}\n\n\t/**\n\t * Trivial class to hold 4 integer values. Used only in FirstPersonDrawer.\n\t */\n\tclass RangePair {\n\t\tpublic int x1;\n\t\tpublic int z1; \n\t\tpublic int x2; \n\t\tpublic int z2;\n\n\t\tRangePair(int xx1, int zz1, int xx2, int zz2) {\n\t\t\tx1 = xx1;\n\t\t\tz1 = zz1;\n\t\t\tx2 = xx2;\n\t\t\tz2 = zz2;\n\t\t}\n\t\t/**\n\t\t * Performs a clip3d operation.\n\t\t * @return true if instance variables have been modified, false otherwise\n\t\t */\n\t\tpublic boolean clip3d() {\n\t\t\t// check special cases for quick decision\n\t\t\tif (z1 > -4 && z2 > -4)\n\t\t\t\treturn false;\n\t\t\tif (x1 > -z1 && x2 > -z2)\n\t\t\t\treturn false;\n\t\t\tif (-x1 > -z1 && -x2 > -z2)\n\t\t\t\treturn false;\n\t\t\t// calculate float pair\n\t\t\tfinal int dx = x2 - x1;\n\t\t\tfinal int dz = z2 - z1;\n\t\t\tFloatPair fp = new FloatPair(0, 1);\n\t\t\tif (!fp.clipt(-dx - dz, x1 + z1))\n\t\t\t\treturn false;\n\t\t\tif (!fp.clipt(dx - dz, -x1 + z1))\n\t\t\t\treturn false;\n\t\t\tif (!fp.clipt(-dz, z1 - 4))\n\t\t\t\treturn false;\n\t\t\t// if float pair is valid, update instance variables\n\t\t\tif (fp.p2 < 1) {\n\t\t\t\tx2 = (int) (x1 + fp.p2 * dx);\n\t\t\t\tz2 = (int) (z1 + fp.p2 * dz);\n\t\t\t}\n\t\t\tif (fp.p1 > 0) {\n\t\t\t\tx1 += fp.p1 * dx;\n\t\t\t\tz1 += fp.p1 * dz;\n\t\t\t}\n\t\t\treturn true;\n\t\t} \n\t}\n\t/**\n\t * Trivial class to hold to double values. Used only in FirstPersonDrawer.\n\t *\n\t */\n\tclass FloatPair {\n\t\tpublic double p1;\n\t\tpublic double p2;\n\n\t\t/**\n\t\t * Constructors, given parameters are stored\n\t\t * @param pp1 stored as p1\n\t\t * @param pp2 stored as p2\n\t\t */\n\t\tFloatPair(double pp1, double pp2) {\n\t\t\tp1 = pp1;\n\t\t\tp2 = pp2;\n\t\t}\n\t    /**\n\t     * Helper method for clip3d\n\t     * @param denom is the denominator\n\t     * @param num is the numerator\n\t     * @return the result of the clipping operation\n\t     */\n\t\tpublic boolean clipt(int denom, int num) {\n\t\t\tif (denom > 0) {\n\t\t\t\tdouble t = num * 1.0 / denom;\n\t\t\t\tif (t > p2)\n\t\t\t\t\treturn false;\n\t\t\t\tif (t > p1)\n\t\t\t\t\tp1 = t; // update field\n\t\t\t} else if (denom < 0) {\n\t\t\t\tdouble t = num * 1.0 / denom;\n\t\t\t\tif (t < p1)\n\t\t\t\t\treturn false;\n\t\t\t\tif (t < p2)\n\t\t\t\t\tp2 = t; // update field\n\t\t\t} else if (num > 0)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\n\t\t}\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/edu/wm/cs/cs301/cheyennehwang/gui/FirstPersonView.java b/app/src/main/java/edu/wm/cs/cs301/cheyennehwang/gui/FirstPersonView.java
--- a/app/src/main/java/edu/wm/cs/cs301/cheyennehwang/gui/FirstPersonView.java	(revision e2caa2e69ff474aa3c2fc03def4fb39736e8548a)
+++ b/app/src/main/java/edu/wm/cs/cs301/cheyennehwang/gui/FirstPersonView.java	(date 1670553254328)
@@ -516,11 +516,11 @@
 			panel.addWall(xps, yps, 4);
 			// for debugging purposes, code will draw a red line around polygon
 			// this makes individual walls visible
-			/*
-			gc.setColor(new Color(240,20,20));
-			gc.drawPolygon(xps, yps, 4);
-			gc.setColor(seg.getColor());
-			*/
+
+//			gc.setColor(new Color(240,20,20));
+//			panel.addPolygon(xps, yps, 4);
+//			gc.setColor(seg.getColor());
+
 			// end debugging
 			drawn = true;           // at least one polygon was drawn, memorize for return value
 			rSet.remove(x1i, x2i);  // update rset, remove interval [x1i,x2i] from to-do list 
Index: app/src/main/java/edu/wm/cs/cs301/cheyennehwang/gui/MazePanel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package edu.wm.cs.cs301.cheyennehwang.gui;\n\n\n\nimport android.annotation.SuppressLint;\nimport android.content.Intent;\nimport android.graphics.BitmapFactory;\nimport android.graphics.BitmapShader;\nimport android.graphics.Matrix;\nimport android.graphics.Path;\nimport android.graphics.Shader;\nimport android.graphics.Typeface;\nimport android.os.Build;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.View;\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\n\nimport androidx.annotation.RequiresApi;\n\nimport edu.wm.cs.cs301.cheyennehwang.R;\n\n/**\n * Class: maze panel view drawer which extends view class\n * @author cheyennehwang\n *\n * Responsibilities: creates the screen that depicts the maze play experience based on user input\n *\n * Collaborators: Map, FirstPersonView, CompassRose, PlayAnimationActivity (State PlayAnimation), PlayManuallyActivity (State PlayManually), UI, MazeFactory, Control\n *\n */\n\npublic class MazePanel extends View implements P7PanelF22{\n    private Bitmap mazeBitmap;\n    private Canvas mazeCanvas;\n    private Paint mazePaint;\n    public static BitmapShader mazeShader;\n    public Typeface mazeFont;\n\n    public boolean canDraw;\n\n    //for flexible view dimesnions\n    public int width;\n    public int height;\n\n    /**\n     * Basic constructor that sets up the maze's canvas and paints\n     */\n    public MazePanel(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mazeBitmap = Bitmap.createBitmap(1000, 1000, Bitmap.Config.ARGB_8888);\n        mazeCanvas = new Canvas(mazeBitmap);\n        mazePaint = new Paint();\n\n        Bitmap image = BitmapFactory.decodeResource(context.getResources(), R.drawable.forest_pic);\n        mazeShader = new BitmapShader(image, Shader.TileMode.MIRROR, Shader.TileMode.MIRROR);\n        canDraw = true;\n\n\n\n    }\n\n    /**\n     * helper method to draw the backgrounds according to specification\n     * @param canvas is the master canvas\n     */\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        Log.v(\"MazePanel\", \"Drawing maze panel\");\n//        myTestImage(mazeCanvas);\n        canvas.drawBitmap(mazeBitmap, 0, 0, mazePaint);\n\n\n    }\n\n    /**\n     * Commits all accumulated drawings to the UI.\n     * Substitute for MazePanel.update method.\n     *\n     * updates based on what's been added to the canvas\n     */\n    @Override\n    public void commit(){\n        // only create new objects in the constructor, redraw the rest\n        // in commit invalidate method which will send it to on draw\n//        mazeCanvas.drawBitmap(mazeBitmap, 0, 0, mazePaint);\n//        mazeBitmap = Bitmap.createBitmap(Constants.VIEW_WIDTH, Constants.VIEW_HEIGHT, Bitmap.Config.ARGB_8888);\n//        mazeCanvas = new Canvas(mazeBitmap);\n        invalidate();\n\n\n    }\n\n\n    /**\n     * Tells if instance is able to draw.\n     * This ability depends on the context, for instance, in a testing environment, drawing may be not possible and not desired.\n     * Substitute for code that checks if graphics object for drawing is not null.\n     *\n     *  @return true if drawing is possible, false if not.\n     */\n    @Override\n    public boolean isOperational(){\n        if ( mazeCanvas == null ){\n            Log.e(\"MazePanel\", \"Can't draw on canvas\");\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Sets the color for future drawing requests\n     * The color setting will remain in effect till this method is called again and with a different color.\n     * Substitute for Graphics.setColor method.\n     *\n     * How its done: sets the paint variable for the mazepanel object to the color requested\n     * @param argb gives the alpha, red, green, and blue encoded value of the color\n     */\n    @Override\n    public void setColor(int argb){\n        mazePaint.setColor(argb);\n    }\n\n    /**\n     * Returns the ARGB value for the current color setting.\n     *\n     * how i did it: checks the paint object for the class which contains current color being used to draw, returns its int val\n     * @return integer ARGB value\n     */\n    @Override\n    public int getColor(){\n\n        int colorVal = mazePaint.getColor();\n        return colorVal;\n    }\n\n\n    /**\n     * Draws two solid rectangles to provide a background.\n     * Note that this also erases any previous drawings.\n     * The color setting adjusts to the distance to the exit to provide an additional clue for the user.\n     * Colors transition from black to gold and from grey to green.\n     * Substitute for FirstPersonView.drawBackground method.\n     *\n     * execution: creates a new canvas for the panel's canvas var to erase previous drawings\n     * draws two rectangles as background as background\n     * uses percent to determine what color to draw the background rectangles\n     *\n     * @param percentToExit gives the distance to exit\n     */\n    @SuppressLint(\"NewApi\")\n    @Override\n    public void addBackground(float percentToExit){\n\n        float halfVar = new Float(49.9f);\n\n        if (percentToExit < halfVar){\n            int skyColor = Color.argb(255, 197, 214, 246);\n            mazePaint.setColor(skyColor);\n            addFilledRectangle(0, 0, width, height/2);\n//            mazePaint.setStyle(Paint.Style.FILL);\n//            mazeCanvas.drawRect(0, 500, 1000, 1000, mazePaint);\n\n            int grassColor = Color.argb(255, 197, 246, 203);\n            mazePaint.setColor(grassColor);\n            addFilledRectangle(0,height/2, width, height/2);\n//            mazePaint.setStyle(Paint.Style.FILL);\n//            mazeCanvas.drawRect(0, 0, 1000, 500, mazePaint);\n        } else {\n            int eveningColor = Color.argb(255, 246, 239, 197);\n            mazePaint.setColor(eveningColor);\n            addFilledRectangle(0, 0, width, height/2);\n//            mazePaint.setStyle(Paint.Style.FILL);\n//            mazeCanvas.drawRect(0, 500, 1000, 1000, mazePaint);\n\n            int grassColor = Color.argb(255, 197, 246, 203);\n            mazePaint.setColor(grassColor);\n            addFilledRectangle(0,height/2, width, height/2);\n//            mazePaint.setStyle(Paint.Style.FILL);\n//            mazeCanvas.drawRect(0, 0, 1000, 500, mazePaint);\n        }\n\n\n    }\n\n    /**\n     * Adds a filled rectangle.\n     * The rectangle is specified with the {@code (x,y)} coordinates\n     * of the upper left corner and then its width for the\n     * x-axis and the height for the y-axis.\n     * Substitute for Graphics.fillRect() method\n     * @param x is the x-coordinate of the top left corner\n     * @param y is the y-coordinate of the top left corner\n     * @param width is the width of the rectangle\n     * @param height is the height of the rectangle\n     */\n    @Override\n    public void addFilledRectangle(int x, int y, int width, int height){\n        mazePaint.setStyle(Paint.Style.FILL);\n        mazeCanvas.drawRect((float) x, (float) y, (float) (x + width), (float) (y + height), mazePaint);\n    }\n\n    /**\n     * Adds a filled polygon.\n     * The polygon is specified with {@code (x,y)} coordinates\n     * for the n points it consists of. All x-coordinates\n     * are given in a single array, all y-coordinates are\n     * given in a separate array. Both arrays must have\n     * same length n. The order of points in the arrays\n     * matter as lines will be drawn from one point to the next\n     * as given by the order in the array.\n     * Substitute for Graphics.fillPolygon() method\n     * @param xPoints are the x-coordinates of points for the polygon\n     * @param yPoints are the y-coordinates of points for the polygon\n     * @param nPoints is the number of points, the length of the arrays\n     */\n    @Override\n    public void addFilledPolygon(int[] xPoints, int[] yPoints, int nPoints){\n        mazePaint.setStyle(Paint.Style.FILL);\n\n\n        Path polyPath = new Path();\n        if (nPoints > 0){\n            polyPath.moveTo(xPoints[0], yPoints[0]);\n            for (int i = 1; i < nPoints; i++){\n                polyPath.lineTo(xPoints[i], yPoints[i]);\n            }\n            polyPath.close();\n        }\n        mazeCanvas.drawPath(polyPath, mazePaint);\n\n    }\n\n    /**\n     * Adds an unfilled polygon.\n     * The polygon is specified with {@code (x,y)} coordinates\n     * for the n points it consists of. All x-coordinates\n     * are given in a single array, all y-coordinates are\n     * given in a separate array. Both arrays must have\n     * same length n. The order of points in the arrays\n     * matter as lines will be drawn from one point to the next\n     * as given by the order in the array.\n     * Substitute for Graphics.drawPolygon method\n     * @param xPoints are the x-coordinates of points for the polygon\n     * @param yPoints are the y-coordinates of points for the polygon\n     * @param nPoints is the number of points, the length of the arrays\n     */\n    @Override\n    public void addPolygon(int[] xPoints, int[] yPoints, int nPoints){\n        //can make add polygon one class with an additional style parameter\n        mazePaint.setStyle(Paint.Style.STROKE);\n\n        Path polyPath = new Path();\n        if (nPoints > 0){\n            polyPath.moveTo(xPoints[0], yPoints[0]);\n            for (int i = 1; i < nPoints; i++){\n                polyPath.lineTo(xPoints[i], yPoints[i]);\n            }\n            polyPath.close();\n        }\n        mazeCanvas.drawPath(polyPath, mazePaint);\n    }\n\n    /**\n     * Adds a line.\n     * A line is described by {@code (x,y)} coordinates for its\n     * starting point and its end point.\n     * Substitute for Graphics.drawLine method\n     * @param startX is the x-coordinate of the starting point\n     * @param startY is the y-coordinate of the starting point\n     * @param endX is the x-coordinate of the end point\n     * @param endY is the y-coordinate of the end point\n     */\n    @Override\n    public void addLine(int startX, int startY, int endX, int endY){\n        mazePaint.setStyle(Paint.Style.FILL);\n\n        mazeCanvas.drawLine((float) startX, (float) startY, (float) endX, (float) endY, mazePaint);\n    }\n\n    /**\n     * Adds a filled oval.\n     * The oval is specified with the {@code (x,y)} coordinates\n     * of the upper left corner and then its width for the\n     * x-axis and the height for the y-axis. An oval is\n     * described like a rectangle.\n     * Substitute for Graphics.fillOval method\n     * @param x is the x-coordinate of the top left corner\n     * @param y is the y-coordinate of the top left corner\n     * @param width is the width of the oval\n     * @param height is the height of the oval\n     */\n    @SuppressLint(\"NewApi\")\n    @Override\n    public void addFilledOval(int x, int y, int width, int height){\n        mazePaint.setStyle(Paint.Style.FILL);\n\n\n        mazeCanvas.drawOval((float) x, (float) y, (float) (x + width), (float) (y + height), mazePaint);\n    }\n\n    /**\n     * Adds the outline of a circular or elliptical arc covering the specified rectangle.\n     * The resulting arc begins at startAngle and extends for arcAngle degrees,\n     * using the current color. Angles are interpreted such that 0 degrees\n     * is at the 3 o'clock position. A positive value indicates a counter-clockwise\n     * rotation while a negative value indicates a clockwise rotation.\n     * The center of the arc is the center of the rectangle whose origin is\n     * (x, y) and whose size is specified by the width and height arguments.\n     * The resulting arc covers an area width + 1 pixels wide\n     * by height + 1 pixels tall.\n     * The angles are specified relative to the non-square extents of\n     * the bounding rectangle such that 45 degrees always falls on the\n     * line from the center of the ellipse to the upper right corner of\n     * the bounding rectangle. As a result, if the bounding rectangle is\n     * noticeably longer in one axis than the other, the angles to the start\n     * and end of the arc segment will be skewed farther along the longer\n     * axis of the bounds.\n     * Substitute for Graphics.drawArc method\n     * @param x the x coordinate of the upper-left corner of the arc to be drawn.\n     * @param y the y coordinate of the upper-left corner of the arc to be drawn.\n     * @param width the width of the arc to be drawn.\n     * @param height the height of the arc to be drawn.\n     * @param startAngle the beginning angle.\n     * @param arcAngle the angular extent of the arc, relative to the start angle.\n     */\n    @SuppressLint(\"NewApi\")\n    @Override\n    public void addArc(int x, int y, int width, int height, int startAngle, int arcAngle){\n        mazePaint.setStyle(Paint.Style.STROKE);\n\n        if (arcAngle > 0){\n            mazeCanvas.drawArc((float) x, (float) y, (float) (x + width), (float) (y + height), (float) startAngle, (float) arcAngle, false, mazePaint);\n        } else {\n            int newStart = startAngle + arcAngle;\n            int newSweep = 0 - arcAngle;\n\n            if (newStart < 0){\n                newStart = newStart + 360;\n            }\n\n            mazeCanvas.drawArc((float) x, (float) y, (float) (x + width), (float) (y + height), (float) newStart, (float) newSweep, false, mazePaint);\n        }\n    }\n\n\n    /**\n     * Adds a string at the given position.\n     * Substitute for CompassRose.drawMarker method\n     * @param x the x coordinate\n     * @param y the y coordinate\n     * @param str the string\n     */\n    @Override\n    public void addMarker(float x, float y, String str){\n        mazePaint.setStyle(Paint.Style.STROKE);\n\n        mazeCanvas.drawText(str, x, y, mazePaint);\n    }\n\n    /**\n     * An enumerated type to match 1-1 the awt.RenderingHints used\n     * in CompassRose and MazePanel.\n     */\n    enum P7RenderingHints { KEY_RENDERING, VALUE_RENDER_QUALITY, KEY_ANTIALIASING, VALUE_ANTIALIAS_ON, KEY_INTERPOLATION, VALUE_INTERPOLATION_BILINEAR } ;\n\n    /**\n     * Sets the value of a single preference for the rendering algorithms.\n     * It internally maps given parameter values into corresponding java.awt.RenderingHints\n     * and assigns that to the internal graphics object.\n     * Hint categories include controls for rendering quality\n     * and overall time/quality trade-off in the rendering process.\n     *\n     * Refer to the awt RenderingHints class for definitions of some common keys and values.\n     *\n     * Note for Android: start with an empty default implementation.\n     * Postpone any implementation efforts till the Android default rendering\n     * results in unsatisfactory image quality.\n     *\n     * @param hintKey the key of the hint to be set.\n     * @param hintValue the value indicating preferences for the specified hint category.\n     */\n    @Override\n    public void setRenderingHint(P7PanelF22.P7RenderingHints hintKey, P7PanelF22.P7RenderingHints hintValue){\n        //TODO fill\n    }\n\n    /**\n     * helper method to test that drawing methods and panel updating actually works\n     */\n    private void myTestImage(Canvas c){\n        setColor(Color.BLUE);\n        addFilledOval(0, 0 , 500, 500);\n\n    }\n\n    /**\n     * helper method meant to replace old add wall involving graphics\n     * meant to translate over directly\n     * also allows for shader to be set without interfering with drawing of non-wall polygons\n     * @param xPoints\n     * @param yPoints\n     * @param nPoints\n     */\n    public void addWall(int[] xPoints, int[] yPoints, int nPoints) {\n        Matrix shaderMatrix = new Matrix();\n        float[] points = new float[nPoints * 2];\n        shaderMatrix.mapPoints(points);\n        mazeShader.setLocalMatrix(shaderMatrix);\n        mazePaint.setShader(mazeShader);\n        mazePaint.setStyle(Paint.Style.FILL);\n\n        addFilledPolygon(xPoints, yPoints, nPoints);\n\n        //resets shader back to old\n        mazePaint.setShader(null);\n    }\n\n    /**\n     * helper method to make the dimensions actaully flexible\n     */\n    public void setFlexibleDimensions(int widthInput, int heightInput){\n        width = widthInput;\n        height = heightInput;\n\n    }\n\n    /**\n     * helper method to set fonts\n     * @param font name\n     */\n    public void setFont(String font) {\n        mazeFont = Typeface.create(font, Typeface.BOLD);\n        mazePaint.setTypeface(mazeFont);\n    }\n\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/edu/wm/cs/cs301/cheyennehwang/gui/MazePanel.java b/app/src/main/java/edu/wm/cs/cs301/cheyennehwang/gui/MazePanel.java
--- a/app/src/main/java/edu/wm/cs/cs301/cheyennehwang/gui/MazePanel.java	(revision e2caa2e69ff474aa3c2fc03def4fb39736e8548a)
+++ b/app/src/main/java/edu/wm/cs/cs301/cheyennehwang/gui/MazePanel.java	(date 1670552471740)
@@ -55,6 +55,7 @@
         mazeBitmap = Bitmap.createBitmap(1000, 1000, Bitmap.Config.ARGB_8888);
         mazeCanvas = new Canvas(mazeBitmap);
         mazePaint = new Paint();
+        mazePaint.setColor(Color.BLACK);
 
         Bitmap image = BitmapFactory.decodeResource(context.getResources(), R.drawable.forest_pic);
         mazeShader = new BitmapShader(image, Shader.TileMode.MIRROR, Shader.TileMode.MIRROR);
